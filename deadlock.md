## 任务要求
在linux或windows系统上运行Deadlock.class，观察何时出现死锁并分析出现死锁的原因。

## 实验过程
1.进入文件夹dol_java

	 cd dol_java
2.在文件夹中拖入写好的文件Deadlock.java
3.编译文件

	javac Deadlock.java
4.在文件夹中拖入bash文件
5.运行bash脚本，循环执行Deadlock.class
	bash Deadlock.sh

6.如果无法成功，尝试修改class Deadlock里面的count值或者bash脚本的循环次数。

## 实验结果

1.
![](http://i.imgur.com/AilXsDg.png)


	将count值改为100000后，第1529次出现了死锁。

2.产生死锁的四个必要条件

死锁就是两个或者多个进程，互相请求对方占有的资源。

* 互斥条件：一个资源每次只能被一个进程使用
* 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
* 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺
* 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系

3.本次实验产生死锁的原因

首先要理解整个程序运行过程。在当前线程1中，创建了线程t（以下称为线程2）,然后调用线程2，延时了count时间后，线程1调用A类的methodA()，而methodA()又想要调用B类的last()，
而线程2调用B类的methodB(),methodB()又想要调用A类的last()。

* 两个类中的方法都被修饰synchronized，所有无法同时访问同一个类的不同方法，也就是互斥条件。
* 线程1占有A想要B的资源，线程2占有B想要A的资源，也就是请求与保持条件。
* 两个线程1和2都不释放自己已经占有的资源，也无法剥夺另一方的资源，就是不剥夺条件。
* 线程1和2互相等待彼此释放资源，也就是循环等待条件。
	